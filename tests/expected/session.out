-- Install core dependencies
\ir ../../sql/00_install.sql
CREATE EXTENSION IF NOT EXISTS pgcrypto;
\ir ../../sql/60_pgb_session.sql
CREATE SCHEMA IF NOT EXISTS pgb_session;
CREATE TABLE IF NOT EXISTS pgb_session.session (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    current_url TEXT NOT NULL,
    state JSONB NOT NULL DEFAULT '{}'::jsonb,
    focus UUID
);
CREATE TABLE IF NOT EXISTS pgb_session.history (
    session_id UUID NOT NULL REFERENCES pgb_session.session(id) ON DELETE CASCADE,
    n BIGINT NOT NULL,
    url TEXT NOT NULL,
    ts TIMESTAMPTZ NOT NULL DEFAULT now(),
    PRIMARY KEY(session_id, n)
);
CREATE OR REPLACE FUNCTION pgb_session.open(p_url TEXT)
RETURNS UUID
LANGUAGE plpgsql
AS $$
DECLARE
    sid UUID;
BEGIN
    IF p_url IS NULL OR p_url = '' THEN
        RAISE EXCEPTION 'url must not be empty';
    END IF;

    IF p_url !~ '^(pgb|https?)://' THEN
        RAISE EXCEPTION 'unsupported URL scheme: %', p_url;
    END IF;

    INSERT INTO pgb_session.session(current_url)
    VALUES (p_url)
    RETURNING id INTO sid;

    INSERT INTO pgb_session.history(session_id, n, url)
    VALUES (sid, 1, p_url);

    RETURN sid;
END;
$$;

COMMENT ON FUNCTION pgb_session.open(p_url TEXT) IS
    'Open a new session. Parameters: p_url - initial URL. Returns: session UUID.';

CREATE OR REPLACE FUNCTION pgb_session.reload(p_session_id UUID)
RETURNS VOID
LANGUAGE plpgsql
AS $$
DECLARE
    v_url TEXT;
    next_n BIGINT;
BEGIN
    SELECT current_url INTO v_url
    FROM pgb_session.session
    WHERE id = p_session_id
    FOR UPDATE;

    IF v_url IS NULL THEN
        RAISE EXCEPTION 'session % not found', p_session_id
            USING ERRCODE = 'PGBSN';
    END IF;

    SELECT COALESCE(max(n), 0) + 1
    INTO next_n
    FROM pgb_session.history
    WHERE session_id = p_session_id;

    INSERT INTO pgb_session.history(session_id, n, url)
    VALUES (p_session_id, next_n, v_url);
END;
$$;

COMMENT ON FUNCTION pgb_session.reload(p_session_id UUID) IS
    'Record a reload event. Parameters: p_session_id - session ID. Returns: void.';
-- Open a new session and capture the ID
SELECT pgb_session.open('pgb://local/demo') AS sid \gset
-- Ensure an ID is returned
SELECT :'sid' IS NOT NULL AS opened;
 opened 
--------
 t
(1 row)

-- Reload the session
SELECT pgb_session.reload(:'sid');
 reload 
--------
 
(1 row)

-- Verify session table has one row
SELECT count(*) AS session_count FROM pgb_session.session;
 session_count 
---------------
             1
(1 row)

-- Verify history table has two entries
SELECT count(*) AS history_count FROM pgb_session.history;
 history_count 
---------------
             2
(1 row)

-- Accept valid URL schemes
SELECT pgb_session.open('http://example.com') IS NOT NULL AS http_opened;
 http_opened 
-------------
 t
(1 row)

SELECT pgb_session.open('https://example.com') IS NOT NULL AS https_opened;
 https_opened 
--------------
 t
(1 row)

-- Reject invalid URL scheme
SELECT pgb_session.open('ftp://example.com');
psql:session.sql:25: ERROR:  unsupported URL scheme: ftp://example.com
CONTEXT:  PL/pgSQL function pgb_session.open(text) line 10 at RAISE
-- Ensure empty URL raises an exception
SELECT pgb_session.open('');
psql:session.sql:28: ERROR:  url must not be empty
CONTEXT:  PL/pgSQL function pgb_session.open(text) line 6 at RAISE
