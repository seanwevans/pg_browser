-- Install core dependencies
\ir ../../sql/00_install.sql
CREATE EXTENSION IF NOT EXISTS pgcrypto;
\ir ../../sql/60_pgb_session.sql
CREATE SCHEMA IF NOT EXISTS pgb_session;
CREATE TABLE IF NOT EXISTS pgb_session.session (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    created_at TIMESTAMPTZ NOT NULL DEFAULT clock_timestamp(),
    current_url TEXT NOT NULL CONSTRAINT session_current_url_check CHECK (current_url ~* '^(pgb|https?)://'),
    state JSONB NOT NULL DEFAULT '{}'::jsonb,
    focus UUID
);
CREATE TABLE IF NOT EXISTS pgb_session.history (
    session_id UUID NOT NULL REFERENCES pgb_session.session(id) ON DELETE CASCADE,
    n BIGINT GENERATED BY DEFAULT AS IDENTITY,
    url TEXT NOT NULL,
    ts TIMESTAMPTZ NOT NULL DEFAULT clock_timestamp(),
    PRIMARY KEY(session_id, n)
);
CREATE TABLE IF NOT EXISTS pgb_session.snapshot (
    session_id UUID NOT NULL REFERENCES pgb_session.session(id) ON DELETE CASCADE,
    ts TIMESTAMPTZ NOT NULL DEFAULT clock_timestamp(),
    state JSONB NOT NULL,
    current_url TEXT NOT NULL,
    PRIMARY KEY(session_id, ts)
);
\ir 60_pgb_session_validate_url.sql
CREATE OR REPLACE FUNCTION pgb_session.validate_url(p_url TEXT)
RETURNS TEXT
LANGUAGE plpgsql
AS $$
DECLARE
    v_url TEXT := trim(p_url);
BEGIN
    IF v_url IS NULL OR v_url = '' THEN
        RAISE EXCEPTION 'url must not be empty'
            USING ERRCODE = 'PGBUV';
    END IF;

    -- Enforce lowercase scheme and basic host/path structure, allowing optional query and fragment components.
    IF v_url !~ '^(pgb|https?)://[A-Za-z0-9.-]+(:[0-9]+)?(/[A-Za-z0-9._~!$&''()*+,;=:@%/-]*)?(\?[A-Za-z0-9._~!$&''()*+,;=:@%/?-]*)?(#[A-Za-z0-9._~!$&''()*+,;=:@%/?-]*)?$' THEN
        RAISE EXCEPTION 'invalid URL: %', v_url
            USING ERRCODE = 'PGBUV';
    END IF;

    RETURN v_url;
END;
$$;
COMMENT ON FUNCTION pgb_session.validate_url(p_url TEXT) IS
    'Validate a URL ensuring it is not empty, trimmed, and uses an allowed scheme
with a valid host/path, optional query, and optional fragment. Returns the
trimmed URL.';
\ir 60_pgb_session_open.sql
CREATE OR REPLACE FUNCTION pgb_session.open(p_url TEXT)
RETURNS UUID
LANGUAGE plpgsql
AS $$
DECLARE
    sid UUID;
    session_state JSONB;
    session_url TEXT;
BEGIN
    p_url := pgb_session.validate_url(p_url);

    INSERT INTO pgb_session.session(current_url)
    VALUES (p_url)
    RETURNING id, state, current_url INTO sid, session_state, session_url;

    INSERT INTO pgb_session.snapshot(session_id, state, current_url)
    VALUES (sid, session_state, session_url);

    INSERT INTO pgb_session.history(session_id, url)
    VALUES (sid, p_url);

    RETURN sid;
END;
$$;
COMMENT ON FUNCTION pgb_session.open(p_url TEXT) IS
    'Open a new session. Parameters: p_url - initial URL. Returns: session UUID.';
CREATE OR REPLACE FUNCTION pgb_session.navigate(p_session_id UUID, p_url TEXT)
RETURNS VOID
LANGUAGE plpgsql
AS $$
BEGIN
    p_url := pgb_session.validate_url(p_url);

    UPDATE pgb_session.session
    SET current_url = p_url
    WHERE id = p_session_id;

    IF NOT FOUND THEN
        RAISE EXCEPTION 'session % not found', p_session_id
            USING ERRCODE = 'PGBSN';
    END IF;

    INSERT INTO pgb_session.history(session_id, url, ts)
    VALUES (p_session_id, p_url, clock_timestamp());

    -- Record a snapshot after navigation to capture the new URL and state
    INSERT INTO pgb_session.snapshot(session_id, state, current_url)
    SELECT id, state, current_url
    FROM pgb_session.session
    WHERE id = p_session_id;
END;
$$;
COMMENT ON FUNCTION pgb_session.navigate(p_session_id UUID, p_url TEXT) IS
    'Navigate to a new URL and record a snapshot. Parameters: p_session_id - session ID; p_url - destination URL. Returns: void.';
\ir 60_pgb_session_reload.sql
CREATE OR REPLACE FUNCTION pgb_session.reload(p_session_id UUID)
RETURNS VOID
LANGUAGE plpgsql
AS $$
DECLARE
    v_url TEXT;
    v_state JSONB;
BEGIN
    SELECT current_url, state INTO v_url, v_state
    FROM pgb_session.session
    WHERE id = p_session_id;

    IF NOT FOUND THEN
        RAISE EXCEPTION 'session % not found', p_session_id
            USING ERRCODE = 'PGBSN';
    END IF;

    INSERT INTO pgb_session.history(session_id, url, ts)
    VALUES (p_session_id, v_url, clock_timestamp());

    -- Capture a snapshot of the session at reload time
    INSERT INTO pgb_session.snapshot(session_id, state, current_url)
    VALUES (p_session_id, v_state, v_url);
END;
$$;
COMMENT ON FUNCTION pgb_session.reload(p_session_id UUID) IS
    'Record a reload event and snapshot the session. Parameters: p_session_id - session ID. Returns: void.';
CREATE OR REPLACE FUNCTION pgb_session.replay(p_session_id UUID, p_ts TIMESTAMPTZ)
RETURNS VOID
LANGUAGE plpgsql
AS $$
DECLARE
    v_state JSONB;
    v_url TEXT;
    v_snap_ts TIMESTAMPTZ;
BEGIN
    -- Acquire a lock on the session row to ensure consistency for
    -- subsequent updates and deletes.
    PERFORM 1
    FROM pgb_session.session
    WHERE id = p_session_id
    FOR UPDATE;

    IF NOT FOUND THEN
        RAISE EXCEPTION 'session % not found', p_session_id
            USING ERRCODE = 'PGBSN';
    END IF;

    SELECT state, current_url, ts
    INTO v_state, v_url, v_snap_ts
    FROM pgb_session.snapshot
    WHERE session_id = p_session_id
      AND ts <= p_ts
    ORDER BY ts DESC
    LIMIT 1;

    IF NOT FOUND THEN
        RAISE EXCEPTION 'snapshot not found for session % at %', p_session_id, p_ts
            USING ERRCODE = 'PGBNS';
    END IF;

    UPDATE pgb_session.session
    SET state = v_state,
        current_url = v_url
    WHERE id = p_session_id;

    DELETE FROM pgb_session.history
    WHERE session_id = p_session_id
      AND ts > v_snap_ts;

    -- Remove snapshots taken after the target snapshot
    DELETE FROM pgb_session.snapshot
    WHERE session_id = p_session_id
      AND ts > v_snap_ts;

    -- Record a new snapshot of the restored state
    INSERT INTO pgb_session.snapshot(session_id, state, current_url)
    VALUES (p_session_id, v_state, v_url);
END;
$$;
COMMENT ON FUNCTION pgb_session.replay(p_session_id UUID, p_ts TIMESTAMPTZ) IS
    'Rewind a session to a snapshot at or before p_ts. Parameters: p_session_id - session ID; p_ts - target timestamp. Example usage: SELECT pgb_session.replay(:session_id, ''2025-08-04T15:30:00Z''::timestamptz); Returns: void.';
CREATE OR REPLACE FUNCTION pgb_session.close(p_session_id UUID)
RETURNS VOID
LANGUAGE plpgsql
AS $$
BEGIN
    DELETE FROM pgb_session.session
    WHERE id = p_session_id;

    IF NOT FOUND THEN
        RAISE EXCEPTION 'session % not found', p_session_id
            USING ERRCODE = 'PGBSN';
    END IF;
END;
$$;
COMMENT ON FUNCTION pgb_session.close(p_session_id UUID) IS
    'Close a session and remove all associated data. Parameters: p_session_id - session ID. Returns: void.';
SET TIME ZONE 'UTC';
SET datestyle TO ISO, YMD;
-- Open a new session and capture the ID
SELECT pgb_session.open('pgb://local/demo') AS sid \gset
-- Ensure an ID is returned
SELECT :'sid' IS NOT NULL AS opened;
 opened 
--------
 t
(1 row)

-- Verify snapshot inserted with initial state and URL
SELECT count(*) = 1 AS snapshot_created
FROM pgb_session.snapshot WHERE session_id = :'sid';
 snapshot_created 
------------------
 t
(1 row)

SELECT state = '{}'::jsonb AND current_url = 'pgb://local/demo' AS snapshot_matches
FROM pgb_session.snapshot WHERE session_id = :'sid';
 snapshot_matches 
------------------
 t
(1 row)

-- Reload the session
SELECT pgb_session.reload(:'sid');
 reload 
--------
 
(1 row)

-- Verify session table has one row
SELECT count(*) AS session_count FROM pgb_session.session;
 session_count 
---------------
             1
(1 row)

-- Verify history table has two entries
SELECT count(*) AS history_count FROM pgb_session.history;
 history_count
---------------
             2
(1 row)

-- Verify snapshot recorded on reload
SELECT count(*) = 2 AS snapshot_count_after_reload
FROM pgb_session.snapshot WHERE session_id = :'sid';
 snapshot_count_after_reload
----------------------------
 t
(1 row)

-- Navigate to new URLs within the session
SELECT pgb_session.navigate(:'sid', 'http://example.com');
 navigate 
----------
 
(1 row)

SELECT pgb_session.navigate(:'sid', 'https://example.org');
 navigate 
----------
 
(1 row)

-- Verify current_url updated
SELECT current_url = 'https://example.org' AS navigated
FROM pgb_session.session WHERE id = :'sid';
 navigated 
-----------
 t
(1 row)

-- Verify history table has four entries for the session
SELECT count(*) AS history_count_after_nav FROM pgb_session.history WHERE session_id = :'sid';
 history_count_after_nav
-------------------------
                       4
(1 row)

-- Verify snapshots recorded on navigations
SELECT count(*) = 4 AS snapshot_count_after_nav
FROM pgb_session.snapshot WHERE session_id = :'sid';
 snapshot_count_after_nav
-------------------------
 t
(1 row)

-- Verify latest snapshot matches current URL
SELECT current_url = 'https://example.org' AS snapshot_latest_url
FROM pgb_session.snapshot WHERE session_id = :'sid' ORDER BY ts DESC LIMIT 1;
 snapshot_latest_url
--------------------
 t
(1 row)

-- Verify history numbering is sequential
SELECT (
    SELECT n FROM pgb_session.history WHERE session_id = :'sid' ORDER BY n DESC LIMIT 1
) = count(*) AS sequential
FROM pgb_session.history WHERE session_id = :'sid';
 sequential 
------------
 t
(1 row)

-- Verify history timestamps increase with navigation order
SELECT bool_and(ts > lag_ts) AS ts_ordered
FROM (
    SELECT ts, lag(ts) OVER (ORDER BY n) AS lag_ts
    FROM pgb_session.history WHERE session_id = :'sid'
) s WHERE lag_ts IS NOT NULL;
 ts_ordered 
------------
 t
(1 row)

-- Reject invalid URL scheme on navigate
DO $$
DECLARE
    v_sid UUID;
BEGIN
    SELECT id INTO v_sid FROM pgb_session.session LIMIT 1;

    BEGIN
        PERFORM pgb_session.navigate(v_sid, 'ftp://example.com');
        RAISE EXCEPTION 'navigate did not fail';
    EXCEPTION
        WHEN sqlstate 'PGBUV' THEN
            RAISE NOTICE 'error raised as expected';
        WHEN others THEN
            RAISE EXCEPTION 'unexpected error: %', SQLERRM;
    END;
END;
$$;
NOTICE:  error raised as expected
-- Close the session
SELECT pgb_session.close(:'sid');
 close 
-------
 
(1 row)

-- Verify session and history cleared
SELECT count(*) AS session_count_after_close FROM pgb_session.session;
 session_count_after_close 
---------------------------
                         0
(1 row)

SELECT count(*) AS history_count_after_close FROM pgb_session.history;
 history_count_after_close 
---------------------------
                         0
(1 row)

-- Accept valid URL schemes
SELECT pgb_session.open('http://example.com') IS NOT NULL AS http_opened;
 http_opened 
-------------
 t
(1 row)

SELECT pgb_session.open('https://example.com') IS NOT NULL AS https_opened;
 https_opened 
--------------
 t
(1 row)

-- Trim surrounding whitespace
SELECT pgb_session.open(' http://example.com ') IS NOT NULL AS http_whitespace_opened;
 http_whitespace_opened
------------------------
 t
(1 row)

-- Accept URLs with query and fragment components
SELECT pgb_session.open('http://example.com/path?foo=bar') IS NOT NULL AS http_query_opened;
 http_query_opened
-------------------
 t
(1 row)

SELECT pgb_session.open('http://example.com/path?foo=bar#frag') IS NOT NULL AS http_query_fragment_opened;
 http_query_fragment_opened
----------------------------
 t
(1 row)

SELECT pgb_session.open('http://example.com/path#frag') IS NOT NULL AS http_fragment_opened;
 http_fragment_opened
---------------------
 t
(1 row)

-- Reject malformed query/fragment URLs
SELECT pgb_session.open('http://example.com/path#frag?bad');
ERROR:  invalid URL: http://example.com/path#frag?bad
CONTEXT:  PL/pgSQL function pgb_session.validate_url(text) line 12 at RAISE
SQL statement "SELECT pgb_session.validate_url(p_url)"
PL/pgSQL function pgb_session.open(text) line 6 at assignment

-- Reject uppercase URL schemes
SELECT pgb_session.open('HTTP://example.com');
ERROR:  invalid URL: HTTP://example.com
CONTEXT:  PL/pgSQL function pgb_session.validate_url(text) line 12 at RAISE
SQL statement "SELECT pgb_session.validate_url(p_url)"
PL/pgSQL function pgb_session.open(text) line 6 at assignment


-- Reject invalid URL scheme on direct insert
DO $$
BEGIN
    BEGIN
        INSERT INTO pgb_session.session(id, created_at, current_url)
        VALUES ('00000000-0000-0000-0000-000000000000', '2000-01-01 00:00:00+00', 'ftp://example.com');
        RAISE EXCEPTION 'insert did not fail';
    EXCEPTION
        WHEN sqlstate '23514' THEN
            RAISE NOTICE 'error raised as expected';
        WHEN others THEN
            RAISE EXCEPTION 'unexpected error: %', SQLERRM;
    END;
END;
$$;
NOTICE:  error raised as expected
-- Ensure empty URL raises an exception

SELECT pgb_session.open('');
ERROR:  url must not be empty
CONTEXT:  PL/pgSQL function pgb_session.validate_url(text) line 4 at RAISE
SQL statement "SELECT pgb_session.validate_url(p_url)"
PL/pgSQL function pgb_session.open(text) line 6 at assignment
    BEGIN
        INSERT INTO pgb_session.session(id, created_at, current_url)
        VALUES ('00000000-0000-0000-0000-000000000002', '2000-01-01 00:00:00+00', 'HTTPS://example.com');
        RAISE EXCEPTION 'insert did not fail';
    EXCEPTION
        WHEN sqlstate '23514' THEN
            RAISE NOTICE 'error raised as expected';
        WHEN others THEN
            RAISE EXCEPTION 'unexpected error: %', SQLERRM;
    END;
END;
$$;
NOTICE:  error raised as expected
NOTICE:  error raised as expected
-- Ensure empty URL raises an exception
DO $$
BEGIN
    BEGIN
        PERFORM pgb_session.open('');
        RAISE EXCEPTION 'open did not fail';
    EXCEPTION
        WHEN sqlstate 'PGBUV' THEN
            RAISE NOTICE 'error raised as expected';
        WHEN others THEN
            RAISE EXCEPTION 'unexpected error: %', SQLERRM;
    END;
END;
$$;
NOTICE:  error raised as expected
-- Validate URLs directly using helper
SELECT pgb_session.validate_url('http://example.com');
 validate_url 
--------------
 http://example.com
(1 row)

DO $$
BEGIN
    BEGIN
        PERFORM pgb_session.validate_url('ftp://example.com');
        RAISE EXCEPTION 'validation did not fail';
    EXCEPTION
        WHEN sqlstate 'PGBUV' THEN
            RAISE NOTICE 'error raised as expected';
        WHEN others THEN
            RAISE EXCEPTION 'unexpected error: %', SQLERRM;
    END;
END;
$$;
NOTICE:  error raised as expected
DO $$
BEGIN
    BEGIN
        PERFORM pgb_session.validate_url('');
        RAISE EXCEPTION 'validation did not fail';
    EXCEPTION
        WHEN sqlstate 'PGBUV' THEN
            RAISE NOTICE 'error raised as expected';
        WHEN others THEN
            RAISE EXCEPTION 'unexpected error: %', SQLERRM;
    END;
END;
$$;
NOTICE:  error raised as expected
