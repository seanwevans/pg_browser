-- Install core dependencies
\ir ../../sql/00_install.sql
CREATE EXTENSION IF NOT EXISTS pgcrypto;
psql:../../sql/00_install.sql:1: NOTICE:  extension "pgcrypto" already exists, skipping
\ir ../../sql/60_pgb_session.sql
CREATE SCHEMA IF NOT EXISTS pgb_session;
psql:../../sql/60_pgb_session.sql:1: NOTICE:  schema "pgb_session" already exists, skipping
CREATE TABLE IF NOT EXISTS pgb_session.session (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    current_url TEXT NOT NULL CONSTRAINT session_current_url_check CHECK (current_url ~* '^(pgb|https?)://'),
    state JSONB NOT NULL DEFAULT '{}'::jsonb,
    focus UUID
);
psql:../../sql/60_pgb_session.sql:9: NOTICE:  relation "session" already exists, skipping
CREATE TABLE IF NOT EXISTS pgb_session.history (
    session_id UUID NOT NULL REFERENCES pgb_session.session(id) ON DELETE CASCADE,
    n BIGINT NOT NULL,
    url TEXT NOT NULL,
    ts TIMESTAMPTZ NOT NULL DEFAULT clock_timestamp(),
    PRIMARY KEY(session_id, n)
);
psql:../../sql/60_pgb_session.sql:17: NOTICE:  relation "history" already exists, skipping
CREATE TABLE IF NOT EXISTS pgb_session.snapshot (
    session_id UUID NOT NULL REFERENCES pgb_session.session(id) ON DELETE CASCADE,
    ts TIMESTAMPTZ NOT NULL DEFAULT now(),
    state JSONB NOT NULL,
    current_url TEXT NOT NULL,
    PRIMARY KEY(session_id, ts)
);
psql:../../sql/60_pgb_session.sql:25: NOTICE:  relation "snapshot" already exists, skipping
\ir 60_pgb_session_validate_url.sql
CREATE OR REPLACE FUNCTION pgb_session.validate_url(p_url TEXT)
RETURNS VOID
LANGUAGE plpgsql
AS $$
BEGIN
    IF p_url IS NULL OR p_url = '' THEN
        RAISE EXCEPTION 'url must not be empty'
            USING ERRCODE = 'PGBUV';
    END IF;

    IF p_url !~* '^(pgb|https?)://' THEN
        RAISE EXCEPTION 'unsupported URL scheme: %', p_url
            USING ERRCODE = 'PGBUV';
    END IF;
END;
$$;
COMMENT ON FUNCTION pgb_session.validate_url(p_url TEXT) IS
    'Validate a URL ensuring it is not empty and uses an allowed scheme.';
\ir 60_pgb_session_open.sql
CREATE OR REPLACE FUNCTION pgb_session.open(p_url TEXT)
RETURNS UUID
LANGUAGE plpgsql
AS $$
DECLARE
    sid UUID;
BEGIN
    PERFORM pgb_session.validate_url(p_url);

    INSERT INTO pgb_session.session(current_url)
    VALUES (p_url)
    RETURNING id INTO sid;

    INSERT INTO pgb_session.history(session_id, n, url)
    VALUES (sid, 1, p_url);

    RETURN sid;
END;
$$;
COMMENT ON FUNCTION pgb_session.open(p_url TEXT) IS
    'Open a new session. Parameters: p_url - initial URL. Returns: session UUID.';
CREATE OR REPLACE FUNCTION pgb_session.navigate(p_session_id UUID, p_url TEXT)
RETURNS VOID
LANGUAGE plpgsql
AS $$
BEGIN
    PERFORM pgb_session.validate_url(p_url);

    -- Acquire a lock on the session row to serialize concurrent
    -- navigations and ensure next_n uniqueness.
    PERFORM 1
    FROM pgb_session.session
    WHERE id = p_session_id
    FOR UPDATE;

    IF NOT FOUND THEN
        RAISE EXCEPTION 'session % not found', p_session_id
            USING ERRCODE = 'PGBSN';
    END IF;

    -- Recalculate next_n after obtaining the lock to avoid conflicts
    -- between concurrent calls.
    SELECT COALESCE(
            (
                SELECT n
                FROM pgb_session.history
                WHERE session_id = p_session_id
                ORDER BY n DESC
                LIMIT 1
            ),
            0
        ) + 1
    INTO next_n;

    UPDATE pgb_session.session
    SET current_url = p_url
    WHERE id = p_session_id;

    INSERT INTO pgb_session.history(session_id, n, url, ts)
    VALUES (p_session_id, next_n, p_url, clock_timestamp());

END;
$$;
COMMENT ON FUNCTION pgb_session.navigate(p_session_id UUID, p_url TEXT) IS
    'Navigate to a new URL. Parameters: p_session_id - session ID; p_url - destination URL. Returns: void.';
\ir 60_pgb_session_reload.sql
CREATE OR REPLACE FUNCTION pgb_session.reload(p_session_id UUID)
RETURNS VOID
LANGUAGE plpgsql
AS $$
DECLARE
    v_url TEXT;
BEGIN
    SELECT current_url INTO v_url
    FROM pgb_session.session
    WHERE id = p_session_id;

    IF NOT FOUND THEN
        RAISE EXCEPTION 'session % not found', p_session_id
            USING ERRCODE = 'PGBSN';
    END IF;

    SELECT COALESCE(
            (
                SELECT n
                FROM pgb_session.history
                WHERE session_id = p_session_id
                ORDER BY n DESC
                LIMIT 1
            ),
            0
        ) + 1
    INTO next_n;

    INSERT INTO pgb_session.history(session_id, n, url, ts)
    VALUES (p_session_id, next_n, v_url, clock_timestamp());

END;
$$;
COMMENT ON FUNCTION pgb_session.reload(p_session_id UUID) IS
    'Record a reload event. Parameters: p_session_id - session ID. Returns: void.';
CREATE OR REPLACE FUNCTION pgb_session.replay(p_session_id UUID, p_ts TIMESTAMPTZ)
RETURNS VOID
LANGUAGE plpgsql
AS $$
DECLARE
    v_state JSONB;
    v_url TEXT;
    v_snap_ts TIMESTAMPTZ;
BEGIN
    -- Acquire a lock on the session row to ensure consistency for
    -- subsequent updates and deletes.
    PERFORM 1
    FROM pgb_session.session
    WHERE id = p_session_id
    FOR UPDATE;

    IF NOT FOUND THEN
        RAISE EXCEPTION 'session % not found', p_session_id
            USING ERRCODE = 'PGBSN';
    END IF;

    SELECT state, current_url, ts
    INTO v_state, v_url, v_snap_ts
    FROM pgb_session.snapshot
    WHERE session_id = p_session_id
      AND ts <= p_ts
    ORDER BY ts DESC
    LIMIT 1;

    IF NOT FOUND THEN
        RAISE EXCEPTION 'snapshot not found for session % at %', p_session_id, p_ts
            USING ERRCODE = 'PGBNS';
    END IF;

    UPDATE pgb_session.session
    SET state = v_state,
        current_url = v_url
    WHERE id = p_session_id;

    DELETE FROM pgb_session.history
    WHERE session_id = p_session_id
      AND ts > v_snap_ts;
END;
$$;
COMMENT ON FUNCTION pgb_session.replay(p_session_id UUID, p_ts TIMESTAMPTZ) IS
    'Rewind a session to a snapshot at or before p_ts. Parameters: p_session_id - session ID; p_ts - target timestamp. Example usage: SELECT pgb_session.replay(:session_id, ''2025-08-04T15:30:00Z''::timestamptz); Returns: void.';
CREATE OR REPLACE FUNCTION pgb_session.close(p_session_id UUID)
RETURNS VOID
LANGUAGE plpgsql
AS $$
BEGIN
    DELETE FROM pgb_session.session
    WHERE id = p_session_id;

    IF NOT FOUND THEN
        RAISE EXCEPTION 'session % not found', p_session_id
            USING ERRCODE = 'PGBSN';
    END IF;
END;
$$;
COMMENT ON FUNCTION pgb_session.close(p_session_id UUID) IS
    'Close a session and remove all associated data. Parameters: p_session_id - session ID. Returns: void.';
SET TIME ZONE 'UTC';
SET datestyle TO ISO, YMD;
-- Open a new session and capture the ID
SELECT pgb_session.open('pgb://local/demo') AS sid \gset
-- Snapshot current state and capture timestamp
INSERT INTO pgb_session.snapshot(session_id, ts, state, current_url)
SELECT :'sid', now(), state, current_url
FROM pgb_session.session WHERE id = :'sid'
RETURNING ts AS snap_ts \gset
-- Mutate session and history
UPDATE pgb_session.session SET current_url = 'pgb://local/other', state = '{"foo":"bar"}' WHERE id = :'sid';
INSERT INTO pgb_session.history(session_id, n, url)
VALUES (:'sid', 2, 'pgb://local/other');
-- Verify state before replay
SELECT current_url, state FROM pgb_session.session WHERE id = :'sid';
    current_url    |     state      
-------------------+----------------
 pgb://local/other | {"foo": "bar"}
(1 row)

SELECT count(*) AS history_count_before FROM pgb_session.history WHERE session_id = :'sid';
 history_count_before 
----------------------
                    2
(1 row)

-- Replay to snapshot timestamp
SELECT pgb_session.replay(:'sid', :'snap_ts');
 replay 
--------
 
(1 row)

-- Verify restored state and history
SELECT current_url, state FROM pgb_session.session WHERE id = :'sid';
   current_url    | state 
------------------+-------
 pgb://local/demo | {}
(1 row)

SELECT count(*) AS history_count_after FROM pgb_session.history WHERE session_id = :'sid';
 history_count_after 
---------------------
                   1
(1 row)

SELECT url FROM pgb_session.history WHERE session_id = :'sid' ORDER BY n;
       url        
------------------
 pgb://local/demo
(1 row)

