CREATE SCHEMA IF NOT EXISTS pgb_session;

CREATE TABLE IF NOT EXISTS pgb_session.session (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    created_at TIMESTAMPTZ NOT NULL DEFAULT clock_timestamp(),
    current_url TEXT NOT NULL CONSTRAINT session_current_url_check CHECK (current_url ~* '^(pgb|https?)://'),
    state JSONB NOT NULL DEFAULT '{}'::jsonb,
    focus UUID
);

COMMENT ON TABLE pgb_session.session IS
    'Active sessions with their current URL and state.';
COMMENT ON COLUMN pgb_session.session.id IS
    'Unique identifier for the session.';
COMMENT ON COLUMN pgb_session.session.created_at IS
    'Timestamp when the session was created.';
COMMENT ON COLUMN pgb_session.session.current_url IS
    'Current URL for the session; must begin with pgb://, http://, or https://, and may include path, query, and fragment components.';
COMMENT ON COLUMN pgb_session.session.state IS
    'Arbitrary JSONB data representing the session state.';
COMMENT ON COLUMN pgb_session.session.focus IS
    'Identifier of the currently focused element, if any.';

CREATE TABLE IF NOT EXISTS pgb_session.history (
    session_id UUID NOT NULL REFERENCES pgb_session.session(id) ON DELETE CASCADE,
    n BIGINT GENERATED BY DEFAULT AS IDENTITY,
    url TEXT NOT NULL,
    ts TIMESTAMPTZ NOT NULL DEFAULT clock_timestamp(),
    PRIMARY KEY(session_id, n)
);

COMMENT ON TABLE pgb_session.history IS
    'Navigation history entries for sessions.';
COMMENT ON COLUMN pgb_session.history.session_id IS
    'Owning session for this history entry.';
COMMENT ON COLUMN pgb_session.history.n IS
    'Sequential number of the history entry within a session.';
COMMENT ON COLUMN pgb_session.history.url IS
    'URL that was visited.';
COMMENT ON COLUMN pgb_session.history.ts IS
    'Timestamp when the URL was recorded.';

CREATE TABLE IF NOT EXISTS pgb_session.snapshot (
    session_id UUID NOT NULL REFERENCES pgb_session.session(id) ON DELETE CASCADE,
    ts TIMESTAMPTZ NOT NULL DEFAULT clock_timestamp(),
    state JSONB NOT NULL,
    current_url TEXT NOT NULL,
    focus UUID,
    PRIMARY KEY(session_id, ts)
);

COMMENT ON TABLE pgb_session.snapshot IS
    'Stored snapshots of session state used for replay.';
COMMENT ON COLUMN pgb_session.snapshot.session_id IS
    'Session associated with this snapshot.';
COMMENT ON COLUMN pgb_session.snapshot.ts IS
    'Timestamp when the snapshot was taken.';
COMMENT ON COLUMN pgb_session.snapshot.state IS
    'Session state captured at the snapshot time.';
COMMENT ON COLUMN pgb_session.snapshot.current_url IS
    'URL that was current when the snapshot was taken.';
COMMENT ON COLUMN pgb_session.snapshot.focus IS
    'Identifier of the currently focused element, if any.';

\ir 60_pgb_session_validate_url.sql
\ir 60_pgb_session_open.sql

CREATE OR REPLACE FUNCTION pgb_session.navigate(p_session_id UUID, p_url TEXT)
RETURNS VOID
LANGUAGE plpgsql
AS $$
BEGIN
    p_url := pgb_session.validate_url(p_url);

    UPDATE pgb_session.session
    SET current_url = p_url
    WHERE id = p_session_id;

    IF NOT FOUND THEN
        RAISE EXCEPTION 'session % not found', p_session_id
            USING ERRCODE = 'PGBSN';
    END IF;

    INSERT INTO pgb_session.history(session_id, url, ts)
    VALUES (p_session_id, p_url, clock_timestamp());

    -- Record a snapshot after navigation to capture the new URL and state
    INSERT INTO pgb_session.snapshot(session_id, state, current_url, focus)
    SELECT id, state, current_url, focus
    FROM pgb_session.session
    WHERE id = p_session_id;
END;
$$;

COMMENT ON FUNCTION pgb_session.navigate(p_session_id UUID, p_url TEXT) IS
    'Navigate to a new URL and record a snapshot. Parameters: p_session_id - session ID; p_url - destination URL. Returns: void.';


\ir 60_pgb_session_reload.sql

CREATE OR REPLACE FUNCTION pgb_session.replay(p_session_id UUID, p_ts TIMESTAMPTZ)
RETURNS VOID
LANGUAGE plpgsql
AS $$
DECLARE
    v_state JSONB;
    v_url TEXT;
    v_focus UUID;
    v_snap_ts TIMESTAMPTZ;
BEGIN
    -- Acquire a lock on the session row to ensure consistency for
    -- subsequent updates and deletes.
    PERFORM 1
    FROM pgb_session.session
    WHERE id = p_session_id
    FOR UPDATE;

    IF NOT FOUND THEN
        RAISE EXCEPTION 'session % not found', p_session_id
            USING ERRCODE = 'PGBSN';
    END IF;

    SELECT state, current_url, focus, ts
    INTO v_state, v_url, v_focus, v_snap_ts
    FROM pgb_session.snapshot
    WHERE session_id = p_session_id
      AND ts <= p_ts
    ORDER BY ts DESC
    LIMIT 1;

    IF NOT FOUND THEN
        RAISE EXCEPTION 'snapshot not found for session % at %', p_session_id, p_ts
            USING ERRCODE = 'PGBNS';
    END IF;

    UPDATE pgb_session.session
    SET state = v_state,
        current_url = v_url,
        focus = v_focus
    WHERE id = p_session_id;

    DELETE FROM pgb_session.history
    WHERE session_id = p_session_id
      AND ts > v_snap_ts;

    -- Remove snapshots taken after the target snapshot
    DELETE FROM pgb_session.snapshot
    WHERE session_id = p_session_id
      AND ts > v_snap_ts;

    -- Record a new snapshot of the restored state
    INSERT INTO pgb_session.snapshot(session_id, state, current_url, focus)
    VALUES (p_session_id, v_state, v_url, v_focus);
END;
$$;

COMMENT ON FUNCTION pgb_session.replay(p_session_id UUID, p_ts TIMESTAMPTZ) IS
    'Rewind a session to a snapshot at or before p_ts. Raises SQLSTATE PGBSN if the session does not exist and PGBNS if no snapshot is found. Parameters: p_session_id - session ID; p_ts - target timestamp. Example usage: SELECT pgb_session.replay(:session_id, ''2025-08-04T15:30:00Z''::timestamptz); Returns: void.';

CREATE OR REPLACE FUNCTION pgb_session.close(p_session_id UUID)
RETURNS VOID
LANGUAGE plpgsql
AS $$
BEGIN
    DELETE FROM pgb_session.session
    WHERE id = p_session_id;

    IF NOT FOUND THEN
        RAISE EXCEPTION 'session % not found', p_session_id
            USING ERRCODE = 'PGBSN';
    END IF;
END;
$$;

COMMENT ON FUNCTION pgb_session.close(p_session_id UUID) IS
    'Close a session and remove all associated data. Raises SQLSTATE PGBSN if the session does not exist. Parameters: p_session_id - session ID. Returns: void.';
